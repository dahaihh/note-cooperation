# 面试总结

[TOC]

## 一、三大框架方面问题

### 1.Spring事务管理

https://www.jianshu.com/p/4183c3fbb7b4

#### （1）分类

**编程式事务：**通过Transaction Template手动管理事务，实际使用很少

**声明式事务：**通过AOP实现

#### （2）声明式事务的四种实现方式

1. **基于 TransactionInterceptor 的声明式事务:** Spring 声明式事务的基础，通常也不建议使用这种方式，了解这种方式对理解 Spring 声明式事务有很大作用。
2. **基于 TransactionProxyFactoryBean 的声明式事务:** 第一种方式的改进版本，简化的配置文件的书写，这是 Spring 早期推荐的声明式事务管理方式，但是在 Spring 2.0 中已经不推荐了。
3. **基于< tx> 和< aop>命名空间的声明式事务管理（AspectJ）：** 目前推荐的方式，其最大特点是与 Spring AOP 结合紧密，可以充分利用切点表达式的强大支持，使得管理事务更加灵活。
4. **基于 @Transactional 的全注解方式：** 将声明式事务管理简化到了极致。开发人员只需在配置文件中加上一行启用相关后处理 Bean 的配置，然后在需要实施事务管理的方法或者类上使用 @Transactional 指定事务规则即可实现事务管理，而且功能也不必其他方式逊色。

#### （3）事务的传播行为--propagation

https://www.cnblogs.com/zsychanpin/p/7074071.html

- @Transactional(propagation=Propagation.**REQUIRED**)  支持当前事务， 如果有事务，那么加入事务, 没有的话新建一个(默认情况下) 
- @Transactional(propagation=Propagation.**NOT_SUPPORTED**)  以非事务方式运行操作。假设当前存在事务，就把当前事务挂起。 
- @Transactional(propagation=Propagation.**REQUIRES_NEW**)  不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务 
- @Transactional(propagation=Propagation.**MANDATORY**)  必须在一个已有的事务中执行,否则抛出异常 
- @Transactional(propagation=Propagation.**NEVER**)  必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反) 
- @Transactional(propagation=Propagation.**SUPPORTS**)  如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务. 
- @Transactional(propagation=Propagation.**NESTED**)  如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。 

https://blog.csdn.net/z69183787/article/details/76208998

#### （4）事务的隔离级别--Isolation

- TransactionDefinition.**ISOLATION_DEFAULT**：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。
- TransactionDefinition.**ISOLATION_READ_UNCOMMITTED**：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。
- TransactionDefinition.**ISOLATION_READ_COMMITTED**：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。
- TransactionDefinition.**ISOLATION_REPEATABLE_READ**：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。
- TransactionDefinition.**ISOLATION_SERIALIZABLE**：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

#### （5）事务超时

所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。 

#### （6）@Transactional注解中常用参数说明 

| 参 数 名 称            | 功 能 描 述                                                  |
| :--------------------- | :----------------------------------------------------------- |
| readOnly               | 该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly=true) |
| rollbackFor            | 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。 |
| rollbackForClassName   | 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。 |
| noRollbackFor          | 该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚 |
| noRollbackForClassName | 该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。 |
| propagation            | 该属性用于设置事务的传播行为。例如：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true) |
| isolation              | 该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置 |
| timeout                | 该属性用于设置事务的超时秒数，默认值为-1表示永不超时         |

### 2.Hibernate与Mybatis的区别与联系

#### （1）简介

**Hibernate**是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。 

**Mybatis**是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。 

#### （2）对比

1. 开发方面

   在项目开发过程当中，就速度而言：

   ​	hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；

   ​	Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；

   但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，发杂语句较多，选择hibernate就不是一个好方案。

2. sql优化方面

   ​	Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；

   ​	Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；

3. 对象管理方面

   ​        Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；

   ​        Mybatis 需要自行管理 映射关系；

4. 缓存方面

   **相同点：**

   Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。

   **不同点：**

   Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是哪种缓存。

   MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。

   **两者比较：**

   因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。

   而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。

#### （3）总结

**Mybatis：**

- MyBatis可以进行更为细致的SQL优化，可以减少查询字段。
- MyBatis容易掌握，而Hibernate门槛较高。


**Hibernate：**

- Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。
- Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。
- Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。
- Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。

## 3.Spring4及5新特性

### （1）spring4新特性

http://jinnianshilongnian.iteye.com/blog/1989381

1. **@RestController** 从Spring4开始，Spring以Servlet3为进行开发，如果用Spring MVC 测试框架的话需要指定Servlet3兼容的jar包（因为其Mock的对象都是基于Servlet3的）。另外为了方便Rest开发，通过新的@RestController指定在控制器上，这样就不需要在每个@RequestMapping方法上加 @ResponseBody了。

2. **mvc:annotation-driven配置变化** 统一风格；将 enableMatrixVariables改为enable-matrix-variables属性；将ignoreDefaultModelOnRedirect改为ignore-default-model-on-redirect。 

3. **提供AsyncRestTemplate用于客户端非阻塞异步支持。**

4. **支持泛型依赖注入。** 

5.  **Map依赖注入：** 这样会注入：key是bean名字；value就是所有实现了BaseService的Bean 

   ```java
   @Autowired  
   private Map<String, BaseService> map; 
   ```

6. **List/数组注入：**这样会注入所有实现了BaseService的Bean；但是顺序是不确定的，如果我们想要按照某个顺序获取；在Spring4中可以使用@Order或实现Ordered接口来实现 

   ```java
   @Autowired  
   private List<BaseService> list;  
   ```

7. **@Lazy可以延迟依赖注入：**  我们可以把@Lazy放在@Autowired之上，即依赖注入也是延迟的；当我们调用userService时才会注入。即延迟依赖注入到使用时。同样适用于@Bean。 

   ```java
   @Lazy  
   @Service  
   public class UserService extends BaseService<User> {  
   }
   @Lazy  
   @Autowired  
   private UserService userService; 
   ```

8. **@Conditional** 

   @Conditional类似于`@Profile（一般用于如我们有开发环境、测试环境、正式机环境，为了方便切换不同的环境可以使用`@Profile指定各个环境的配置，然后通过某个配置来开启某一个环境，方便切换`）`，但是@Conditional的优点是允许自己定义规则。可以指定在如@Component、@Bean、@Configuration等注解的类上，以绝对Bean是否创建等。  

9. **基于CGLIB的类代理不再要求类必须有空参构造器了：** 

   这是一个很好的特性，使用构造器注入有很多好处，比如可以只在创建Bean时注入依赖，然后就不变了，如果使用setter注入，是允许别人改的。当然我们可以使用spring的字段级别注入。如果大家使用过如Shiro，我们可能要对Controller加代理。如果是类级别代理，此时要求Controller必须有空参构造器，有时候挺烦人的。 

10. 集成Bean Validation 1.1(JSR-349)到SpringMVC

11. Groovy Bean定义DSL

12. 更好的Java泛型操作API

13. JSR310日期API的支持

14. [注解、脚本、任务、MVC等其他特性改进](http://jinnianshilongnian.iteye.com/blog/1995111)  

### （2）spring5新特性

## 二、数据库方面

### 1.数据库并发事务存在的问题（脏读、不可重复读、幻读等）

**脏读** : 一个事务读取到另一事务未提交的更新数据 

**不可重复读** : 在同一事务中, 多次读取同一数据返回的结果有所不同, 换句话说,  后续读取可以读到另一事务已提交的更新数据. 相反, "可重复读"在同一事务中多次 读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据

 **幻读** : 一个事务读到另一个事务已提交的insert数据 

https://blog.csdn.net/starlh35/article/details/76445267

## 三、项目优化方面

### 1.web项目性能优化

#### （1）前端优化

1. 压缩源码和图片 JavaScript文件源代码可以采用混淆压缩的方式，CSS文件源代码进行普通压缩，JPG图片可以根据具体质量来压缩为50%到70%，PNG可以使用一些开源压缩软件来压缩，比如24色变成8色、去掉一些PNG格式信息等。
2. 选择合适的图片格式 如果图片颜色数较多就使用JPG格式，如果图片颜色数较少就使用PNG格式，如果能够通过服务器端判断浏览器支持WebP，那么就使用WebP格式和SVG格式。
3. 合并静态资源 包括CSS、JavaScript和小图片，减少HTTP请求。有很大一部分用户访问会因为这一条而取得最大受益。
4. 开启服务器端的Gzip压缩 这对文本资源非常有效，对图片资源则没那么大的压缩比率。
5. 使用CDN 或者一些公开库使用第三方提供的静态资源地址（比如jQuery、normalize.css）。一方面增加并发下载量，另一方面能够和其他网站共享缓存。
6. 延长静态资源缓存时间 这样，频繁访问网站的访客就能够更快地访问。不过，这里要通过修改文件名的方式，确保在资源更新的时候，用户会拉取到最新的内容。
7. 把CSS放在页面头部，把JavaScript放在页面底部 这样就不会阻塞页面渲染，让页面出现长时间的空白。 

另，其他具体详解： 

[1、Web 前端优化最佳实践之 内容篇](http://dbanotes.net/web/best_practices_for_speeding_up_your_web_site_content.html) 

[2、Web 前端优化最佳实践之 Server 篇](http://www.dbanotes.net/web/best_practices_for_speeding_up_your_web_site_server.html) 

[3、Web 前端优化最佳实践之 Cookie 篇](http://dbanotes.net/web/best_practices_for_speeding_up_your_web_site_server_cookie.html) 

[4、Web 前端优化最佳实践之 CSS 篇](http://dbanotes.net/web/best_practices_for_speeding_up_your_web_site_css.html)

[5、Web 前端优化最佳实践之 JavaScript 篇](http://dbanotes.net/web/best_practices_for_speeding_up_your_web_site_javascript.html) 

[6、Web 前端优化最佳实践之 图象篇](http://dbanotes.net/web/best_practices_for_speeding_up_your_web_site_image.html)

[7、Web 前端优化最佳实践之 Mobile(iPhone) 篇](http://dbanotes.net/web/best_practices_for_speeding_up_your_web_site_server_mobile.html)

[如何提高网页效率的14条建议](http://www.cnblogs.com/JustinYoung/archive/2007/11/20/speeding-up-web-site-14rule.html)

[如何提高网页的效率（下篇）——Use YSlow to know why your web Slow](http://www.cnblogs.com/JustinYoung/archive/2007/11/28/speeding-up-web-site-yslow.html) 

#### （2）后端优化

[Web项目开发性能优化解决方案——服务端](http://blog.csdn.net/column/details/webxingneng.html) 

## 四、设计模式

### 1.单例模式

##### （1）简介

1. 饿汉模式（Eager Load）

   ```java
   public class God {
       private static final God god = new God(); //自由的，永有的神单例
       private God(){} //构造方法私有化
       public static God getInstance() { // 请神方法公开化
           return god;
       }
   }
   ```

   

2. 懒汉模式（Lazy Load）（线程不安全）

   ```java
   public class God {
       private static God god; //这里不进行实例化
       private God(){} //构造方法私有化
       public static God getInstance() {
           if (god == null) {
               god = new God();
           }
           return god;
       }
   }
   ```

3. 懒汉模式（多线程优化，方法上加同步）

   ```java
   public class God {
       private static God god;//这里不进行实例化
       private God(){}
       public static synchronized God getInstance() {//此处加入同步
           if (god == null) {//如果无神才造神
               god = new God();
           }
           return god;
       }
   }
   ```

   

4. 懒汉模式（多线程优化，方法内加同步）（双重锁模式）

   ```java
   public class God {
       private volatile static God god;
       private God(){} 
       public static God getInstance() {//庙是开放的不用排队进入
           if (god == null) {//如果头柱香未产生，这批抢香人进入堂内排队。
               synchronized(God.class){
                   if (god == null) {//只有头香造了神，其他抢香的白排队了
                       god = new God();
                   }
               }
           }
           //此处头柱香产生后不必再排队
           return god;
       }
   }
   ```

5. 静态内部类

   ```java
   public class God() {
       private God(){}
       private static class singletonGod() {
           private static final God god = new God();
       }
       public static God getInstance() {
           return singletonGod.god;
       }
   }
   ```

   

6. 枚举

   ```java
   public enum Singleton {
       INSTANCE;
       public void whateverMethod() {
   
       }
   }
   ```

##### （2）单例模式的优点

> 1，在内存中只有一个对象，节省内存空间。
>
> 2，避免频繁的创建销毁对象，可以提高性能。
>
> 3，避免对共享资源的多重占用。
>
> 4，可以全局访问。

##### （3）单例模式的缺点

> 1，扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。
>
> 2，隐式使用引起类结构不清晰。
>
> 3，导致程序内存泄露的问题。

##### （4）适用场景

> 1，需要频繁实例化然后销毁的对象。
>
> 2，创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
>
> 3，资源共享的情况下，避免由于资源操作时导致的性能或损耗等
>
> 4，控制资源的情况下，方便资源之间的互相通信。

##### [注意事项等](https://www.javazhiyin.com/466.html)

### 2.工厂模式

#### （1）简单工厂模式（静态工厂模式）

##### （1）例子

```java
public abstract class INoodles {
    /**
     * 描述每种面条啥样的
     */
    public abstract void desc();
}

public class LzNoodles extends INoodles {
    @Override
    public void desc() {
        System.out.println("兰州拉面 上海的好贵 家里才5 6块钱一碗");
    }
}

public class PaoNoodles extends INoodles {
    @Override
    public void desc() {
        System.out.println("泡面好吃 可不要贪杯");
    }
}

public class GankouNoodles extends INoodles {
    @Override
    public void desc() {
        System.out.println("还是家里的干扣面好吃 6块一碗");
    }
}

public class SimpleNoodlesFactory {
    public static final int TYPE_LZ = 1;//兰州拉面
    public static final int TYPE_PM = 2;//泡面
    public static final int TYPE_GK = 3;//干扣面

    public static INoodles createNoodles(int type) {
        switch (type) {
            case TYPE_LZ:
                return new LzNoodles();
            case TYPE_PM:
                return new PaoNoodles();
            case TYPE_GK:
            default:
                return new GankouNoodles();
        }
    }
}

/**
 * 简单工厂模式
 */
 INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK);
 noodles.desc();
```

##### （2）特点

> 1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。
>
> 2 create()方法通常是静态的，所以也称之为静态工厂。

##### （3）缺点

> 1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）
>
> 2 不同的产品需要不同额外参数的时候 不支持。

#### （2）工厂方法模式（多形性工厂）

##### （1）例子

```java
public interface Car {    
    void gotowork();
}

public class Bike implements Car {
    @Override
    public void gotowork() {
        System.out.println("骑自行车去上班！");
    }
}

public class Bus implements Car {
    @Override
    public void gotowork() {
        System.out.println("坐公交车去上班！");
    }
}

public interface ICarFactory {
    Car getCar();
}

public class BikeFactory implements ICarFactory {
    @Override
    public Car getCar() {
        return new Bike();
    }
}

public class BusFactory implements ICarFactory {    
@Override
    public Car getCar() {        
        return new Bus();
    }
}

public class TestFactory {
    @Test
    public void test() {
        ICarFactory factory = null;
        // bike
        factory = new BikeFactory();
        Car bike = factory.getCar();
        bike.gotowork();
 
        // bus
        factory = new BusFactory();
        Car bus = factory.getCar();
        bus.gotowork();
    }
}
```

##### （2）特点

> 可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。
>
> 可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。
> 可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。

例如：hibernate里通过sessionFactory创建session、通过代理方式生成ws客户端时，通过工厂构建报文中格式化数据的对象。 

#### （3）抽象工厂模式（工具箱）

##### （1）例子

```java
interface IProduct1 {  
    public void show();  
}  
interface IProduct2 {  
    public void show();  
}  
  
class Product1 implements IProduct1 {  
    public void show() {  
        System.out.println("这是1型产品");  
    }  
}  
class Product2 implements IProduct2 {  
    public void show() {  
        System.out.println("这是2型产品");  
    }  
}  
  
interface IFactory {  
    public IProduct1 createProduct1();  
    public IProduct2 createProduct2();  
}  
class Factory implements IFactory{  
    public IProduct1 createProduct1() {  
        return new Product1();  
    }  
    public IProduct2 createProduct2() {  
        return new Product2();  
    }  
}  
  
public class Client {  
    public static void main(String[] args){  
        IFactory factory = new Factory();  
        factory.createProduct1().show();  
        factory.createProduct2().show();  
    }  
}
```

##### （2）与工厂方法模式的区别

> 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。 

##### （3）特点

> 抽象工厂模式的优点
>
> ​        抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。
>
> 抽象工厂模式的缺点
>
> ​       产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

##### （4）适用场景

>        当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。 

无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。 

### 3.原型模式



目录材料

https://blog.csdn.net/moneyshi

[设计模式](https://www.javazhiyin.com/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/page/2)

[设计模式是什么鬼](https://www.javazhiyin.com/topic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC)